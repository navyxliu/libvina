\section{Discussion and Future work}\label{sec:con}
%The silicon industry has chosen multicore as new
%direction. However, diverging multicore architectures enlarge the gap between algorithm-centric programmers and
%computer system developers.  Conventional C/C++ programming language
%can not reflect hardware.  Existing ad-hoc techniques
%or platform-dependent programming language pose issues of generality
%and portability. 
%Source-to-source transformation can meet the challenge
%and help tailor programs to specific multicore architectures.

%Not only the more processor cores but also
%elaborated memory hierarchy and exposed communication are adopted by
%new multicore architectures. More worse, 

We present a template metaprogramming approach to perform source-to-source
transformations for programs with rich information. All functionalities
are achieved within ISO C++ and organized as template library. The
library is flexible enough to
apply more than one parallel
pattern and execution model. In addition, programmers can extend library to
facilitate appropriate parallel patterns or new architectural
features because template metaprogramming is
intimate for C++ developers.  Experiments show
that our template approach can transform algorithms into SPMD threads
with competitive performance. These transformations are available for
both CPU and GPU, while the cost of migration is manageable. Besides, we
can apply hierarchical division for programs on CPU. We also
transform a group of standalone functions into a
pipeline using our template library. It demonstrates that template
metaprogramming is powerful enough to support more than one way to
parallelize for multicore.

%Our programming model bridges algorithm experts and diverging multcore
%architectures. Domain-specific experts focus on algorithms in form of
%conventional programming languages. They wrap functions to template
%classes and then pass them to \emph{TF class} as template parameter. Template
%mechniasm takes responisbility to transform source code according to
%their targets.

%Streaming is an important computation model for innovative
%multicore architectures~\cite{imagine, cellbe, larrabee, cuda}. We partially exploit GPU functionality in this
%paper, however, the transformations for GPU are quite
%straightforward.  It is still unclear how many efforts need to
%pay for a full-blown template library, which supports
%streaming computation.

% Libvina can only deal with regular
%data. Future work on view class  will concentrate on supporting
%general operations like gather and scatter etc.  
On CPU, source-to-source transformation should go on improving data
locality of programs. We plan to explore template approach to  generalize
blocking and tiling techniques.  It is also possible to re-structure
or prefetch data using template metaprograming accompanying with
runtime library.

Currently, kernel functions in GPUs prohibit recursion. We believe that
it would be beneficial to introduce template recursion for
GPUs. In addition, it is attractive for us to explore source transformations for
strip-mined memory accesses in metaprogramming, because modern GPUs
provide memory coalescence to optimize memory.


General applications also contain a variety of static information to
optimize.The problem is that their memory footprints are irregular and
very hard to identify. It is desirable to explores new TF classes to facilitate
transforming source code close to target architectures using the static
information.
