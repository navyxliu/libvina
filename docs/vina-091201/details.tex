\section{Implementation}
\label{sec:details}

We implement all the functionalities described before using C++
template metaprogramming technique. The grand idea is to utilize
template specialization and recursion to achieve control flow at
compile time. Besides template mechanism, other  C++ high level
abstracts act important roles in our approach. Function object and bind
mechnism is critical to postpone computation at proper place with
proper enviroment~\cite{moderncpp}. In order to utilize nested buiding blocks,
lambda expression can generate closure objects in a concise
form, e.g., line 24$\sim$37 of \reffig{sgemm}.

\subsection{Buiding Block Classes}

Implemenation of building blocks are straightforward. We use recursive calls
to support nesting patterns. \code{seq} and \code{par} are interoperable
because we chose proper nested class before calling function \code{apply}. Note that
building blocks do not know the nesting levels during the execution. To solve this
problem, each function object or cloure object is decorated with a loop-variable
counter.
%The handlers take responsibility for calculating loop variables in
%normalized form. It is only desirable for nested loop forms,
%\textit{e.g.} line 41 of List 1.
\todo{
Because some callable objects in C++ such as clousure object
do not provide default constructors, we pass their
references in those cases.  Consequently, some call sites of building blocks are different
from \reftable{bb}.}

For CPU, building blocks are implemented by embedding OpenMP directives. On GPU, we bind
building block classes to functions of OpenCL~\cite{opencl}, an open standard API
for heterogenous muliticores.

\subsection{TF class}

\code{TF\_hierarchy} has two template class definitions. The prime template
calls back task's inner function, while the partial specialization calls
leaf. We utilize predicate similar to Merge~\cite{merge} to generate subtasks
recursively. The main difference from Merge is that our predicate is a
\emph{metafunction} and is evaluated in place, e.g., line 3 below.

\begin{lstlisting}
  template <class TASK,
    template<class, class>  class PRED,
    bool SENTINEL = PRED<ARG0, ARG1>::value>
  struct TF_hierarchy{...}

  template <class TASK,
    template<class, class>  class PRED>
  struct TF_hierarchy<TASK, true>
  {...};
\end{lstlisting}

The \code{TF\_pipeline} class using variadic template~\cite{vartemp}. The
simplified implementation is listed as follows, which supports an arbitrary
number of functions. The only limitation is the maximal level of template
recursions of a compiler.

%For C++ compilers don't support variadic template, there
%are workarounds to achieve the same effect, but quite
%tedious.\footnote{zhangsq ask me to cite. I implemented the
 % workarounds myself, but i don't see it is necessary to show them here. too
 % details... --xliu 28. Nov}.

\begin{lstlisting}
 template <class P, typename... Tail>
  struct pipeline<P, Tail...> {
    typedef typename P::input_type in_t;
    typedef typename P::output_type out_t;
   
    static out_t doit(in_t in)
    {
     pipeline<Tail...>::doit( P::doit(in) );
    }
  };  
\end{lstlisting}

%end section
