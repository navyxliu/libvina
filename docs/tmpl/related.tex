\section{Related work}
As mentioned before, it is desirable to extend conventional programming languages to reflects new hardwares. Researches in the field have two major directions:
\begin{enumerate}
\item providing new library to support programming for concurrency
\item extending language constructs to extend parallel semantics
\end{enumerate}

First, library is a common method to extend language capability
without modifying grammar. Pthread library is a \textit{de facto} standard for
multi-threading on POSIX-compatible systems. The relationship between
pthread and native thread is straightforward. Therefore, abstraction
of pthread is far away from expressing parallelism and concurrency
naturally. Furthermore, the implementation of thread on hardware is
undefined in the standard, so it can not guarantee performance or even
correctness on some architectures \cite{Boehm05}. C++ community intend to develop parallel library while bearing
generic programming in mind. TBB~\cite{tbb} has a plenty of
containers and execution rules. Entities including partitioner and
scheduler in TBB are created at run time. In that case, key data
structures have to be thread-safe. Although TBB exploits task
parallelism or other sophisticated concurrency on general purpose
processors, the runtime overhead is relative high in data parallel
programs, especially in the scenario that many lightweight threads are
executing by hardware. Template-based approach we proposed is orthogonal to runtime parallel
libraries. We only explore parallelism which can be determined at
compile time, developers feel free to deploy other ways such as TBB to
farther improve programs.
 
%% MPI
%Another dominant parallel library is MPI in supercomputing community. It based on message-passing mechanism and SPMD model to execute parallel program. The difficulties of developing MPI programs are as notorious as pthread counterpart for programmers without sufficent training of parallel programming. 
%%

%OpenMP ~\cite{openmp} is designed for shared memory and has been shipped in almost every C/Fortran
%compilers.
%OpenMP can only perform Fork-Join parallel model.
%Source-to-Source transformation for optimization was reported by~\cite{Loveman77}, whose granularity of transformation  is
%statement.  Most of works have been merge in forms of IR in
%modern compilers. New source-to-source transformation compilers focus
%on function. 

The second choice for language community is to extend language constructs by
modifying compiler. They add directive or annotation to help compiler
transform source code. OpenMP compilers transform sequential code into
multi-threaded equivalence. The run-time is usually provides in the form of dynamic link library. Although it is simple and
portable, the performance is not optimal in most cases. Moreover, a
handful of directives in OpenMP leave small room for further improving
performance or scaling up to larger systems. Hybrid OpenMP with MPI is
possible though, difficulties surge. Sequoia supports
programming memory hierarchy. First of all, It targets execution
environment as a tree of machines, which an individual machine owns
its storage and computation unit. Second, it transforms a
\textit{task} into a
cluster of \emph{variants}. Target machine
is described in XML files. \cite{sequoia, sequoia-compiler} report  that Sequoia can transform programs
for CellBE, cluster while keeping competitive performance. That
is at expense of implementing one compiler for each platforms.
The primary drawback of Sequoia is that its language constructs can not cover common
parallel patterns such as pipeline or task queue. Besides, sequoia compiler
ignores type information to select optimal
implementation. Merge~\cite{merge} features a uniform runtime
environment for heterogeneous multicore 
systems in forms of task and variant. However, Merge only
support \emph{map-reduce} programming model. Its run-time overhead is not negligible for fine-granularity
parallelism. Methods mentioned before all need non-trivial efforts to
modify compilers. As discussed in \cite{sequoia}, the authors of the Sequoia were
still not clear whether the minimal set of primitives they provided provides can
sufficiently express dynamic applications. We doubt if it is worthwhile to
invest a compiler given the fact that template library can also
achieve the same functionalities.

